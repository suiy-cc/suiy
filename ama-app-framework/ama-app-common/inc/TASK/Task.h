/*
 * Copyright (C) 2016-2017 Neusoft, Inc.
 * All Rights Reserved.
 *
 * The following programs are the sole property of Neusoft Inc.,
 * and contain its proprietary and confidential information.
 */
/// @file Task.h
/// @brief contains class Task
///
/// Created by zs on 2016/6/7.
/// this file contains the definination of class Task
///

#ifndef TASK_H
#define TASK_H

#include <list>
#include <map>
#include <stdio.h>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <string.h>
#include <unistd.h>
#include <deque>

#include <COMMON/ThreadSafeValueKeeper.h>

#ifndef gettid
#include <sys/syscall.h>
#define gettid() syscall(__NR_gettid)
#define getpid() syscall(__NR_getpid)
#endif

// sleeep ms
#ifndef CPU_Sleep
#ifdef WIN32
#define CPU_Sleep(millisecond)  Sleep(millisecond)
#else
#define CPU_Sleep(millisecond)  usleep((millisecond)*(1000))
#endif
#endif

using namespace std;

static int totalTaskID = 0;

enum E_TASK_PRIORITY
{
    ///normal priority
    E_TASK_PRIORITY_NORMAL = 0,
    ///high priority
    E_TASK_PRIORITY_HIGH,
};

/// @class Task
/// @brief this class is the abstraction of a task
///
/// a task is a message sent by an app or a system
/// service to request system service.
class Task
: public std::enable_shared_from_this<Task>
{
public:
    /// @name constructor and destructor
    /// @{
    Task();
    virtual ~Task();
    /// @}

    /// @name getters & setters
    /// @{
    void SetPriority(E_TASK_PRIORITY priority);
    E_TASK_PRIORITY GetPriority()const;
    void SetType(int taskType);
    int GetType()const;
    void SetThisIsWatchDogTask(void);
    bool IsWatchDotTask(void);
    int GetID(void)const;
    void SetUserData(unsigned long long data, std::function<void(unsigned long long)> f = nullptr);
    unsigned long long GetUserData();
    void SetReplyTask(bool isReplyTask);
    const function<void()> &GetReplyReceiver() const;
    void SetReplyReceiver(const function<void()> &receiver);
    const function<void(std::shared_ptr<Task>)> &GetPreTaskDoneCB()const;
    void SetPreTaskDoneCB(const function<void(std::shared_ptr<Task>)> &onPreTaskDone);
    const function<void(std::shared_ptr<Task>)> &GetTaskDoneCB()const;
    void SetTaskDoneCB(const function<void(std::shared_ptr<Task>)> &onTaskDone);
    unsigned long long GetTaskDoneCBData()const;
    void SetTaskDoneCBData(unsigned long long data, const function<void(unsigned long long)> f = nullptr);
    /// @}

    virtual string GetTaskTypeString(){return "GetTaskTypeString() is not implemented.";}

protected:
    friend class TaskHost;
    friend class TaskDispatcher;
    /// @name task reply system
    /// @{
    virtual bool IsReplyTask();
    virtual void SendReply();
    virtual void OnReceiveReply();
    virtual std::shared_ptr<Task> GetParent();
    virtual void SetParent(std::shared_ptr<Task> task);
    virtual std::shared_ptr<Task> FrontChild();
    virtual void PushChild(std::shared_ptr<Task> task);
    virtual void PopChild();
    virtual void ClearChild();
    virtual void EraseChild(const Task *task);
    virtual void ReplaceChild(const Task *task, std::shared_ptr<Task> newChild);
    virtual void ReplaceChild(const Task *task, const ThreadSafeValueKeeper<std::deque<std::shared_ptr<Task>>>& newChildren);
    virtual bool IsAMissingChild();
    /// @}

    void OnPreTaskDone();
    void OnTaskDone();

private:
    /// @name task reply system
    /// @{
    virtual void _Reply();
    /// @}

private:
    E_TASK_PRIORITY priority;
    bool mIsWatchDogTask;
    int type;
    int ID; // task ID

    // user data
    unsigned long long userData;
    std::function<void(unsigned long long)> freeUserData;

    /// @name task callback
    /// @{
    unsigned long long taskDoneCallbackData;
    std::function<void(unsigned long long)> freeTaskDoneCallbackData;
    std::function<void(std::shared_ptr<Task>)> onPreTaskDone; // invoked before current task is going to be done
    std::function<void(std::shared_ptr<Task>)> onTaskDone; // invoked after current task is done
    /// @}

    // for task reply system
    std::function<void(void)> onReplyReceive;
    bool isReplyTask;
    std::shared_ptr<Task> replyTask;
    ThreadSafeValueKeeper<std::shared_ptr<Task>> parent;
    ThreadSafeValueKeeper<std::deque<std::shared_ptr<Task>>> children;
};

template<typename... T>
std::tuple<T...>* GetZippedArguments(T... arguments)
{
    return new std::tuple<T...>(arguments...);
}

// zip arguments into a pointer to a std::tuple object
#define ZIP_ARG(...) GetZippedArguments(__VA_ARGS__)

//#define ZIP_ARG() new decltype(std::make_tuple(_seat, width, height))(std::make_tuple(_seat, width, height));

// generate the argument list of Task::SetUserData() from a pointer generated by macro ZIP_ARG
#define TO_USERDATA(ptr) reinterpret_cast<unsigned long long>(ptr),[ptr](unsigned long long __data){delete reinterpret_cast<decltype(ptr)>(__data);}

// reference a specified argument from the tuple pointer generated by macro ZIP_ARG in a task object with user data set by macro FROM_RAW_PTR
#define REF_ARG(task_ptr, type, i) (std::get<(i)>(*(reinterpret_cast<type>(task_ptr->GetUserData()))))

#endif//TASK_H
